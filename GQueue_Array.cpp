 //CIRCULAR QUEUE
/*
* This code is generated by KRISHNA AGRAWAL
*/



class GQueue
{
	int queue[size];
	int front=-1,rear=-1;
	public:	
	~GQueue();
	void queueFrame();
	void queueInput();
	void enQueue();//insert an element at the rear end
	void deQueue();//delete an element at the front end	
};


void GQueue :: queueFrame()
{
	_Main obj;
	obj.init();//Defined in _Main
	obj.footer();//Defined in _Main
	
	setcolor(2);//Green
	settextstyle(1,0,6);//font,direction,charsize
	outtextxy(100,50,"Circular Queue(Static Implementation)");
	setcolor(15); //White Color code
	line(50,200,50,300);
	line(50,300,1500,300);
	line(1500,300,1500,200);
	line(1500,200,50,200);
	int i=200,xMid=125;
	settextstyle(1,0,3);//font,direction,charsize
	for(int x=0;x<=9;x=x+1)
	{
		line(i,200,i,300);
		char *co = obj.int_to_charP(x); //Defined in _Main					
		outtextxy(xMid,310,co);
		i = i + 150;
		xMid = xMid + 150;
	}
	
	//front and rear pointer code
	rectangle(200,450,350,525);//left,top,right,bottom
	rectangle(200,600,350,675);
	setcolor(13);//cyan
	settextstyle(1,0,4);//font,direction,charsize
	outtextxy(80,480,"Rear");
	outtextxy(80,630,"Front");
	settextstyle(1,0,3);
	outtextxy(250,480,"-1");//rear
	outtextxy(250,630,"-1");//front
		
	setcolor(14);
	settextstyle(1,0,5);
	outtextxy(600,400,"Press 1 for EnQueue");
	outtextxy(600,500,"Press 2 for DeQueue");
	setcolor(15);
}//End of queueFrame function()


void GQueue :: queueInput()
{
	_Main obj;
	int choice;
	char inputCh,another='y';
	char res[10];
	do{
		obj.clearPixel(600,550,1400,750); //defined in _Main
		setcolor(15);//White
		rectangle(600,600,1400,700); //delay(5000);do left,top,right,bottom
		circle(1300,650,65);
		settextstyle(1,0,3);
		outtextxy(630,630,"	Enter Your Choice ");
		try{
				fflush(stdin);		
		 		inputCh = getch();
				int errorMessage =-1;
		 		if( !(inputCh>=48 && inputCh<=57) )
				{
					char *inputChP=&inputCh;
					outtextxy(1280,630,inputChP);
					throw  errorMessage;
				}
			}
			catch (int errorMessage)
			{			
				setcolor(RED);
				settextstyle(1,0,4);
				outtextxy(630,630,"Invalid Input Exception");
				delay(2000);
				continue;;
			}					
			choice = inputCh - '0';//char to int conversion
				
			/*Con version from int to char*  */
			char *co = obj.int_to_charP(choice);
			outtextxy(1280,630,co);
			delay(1000);
			switch(choice)
			{
				case 1: enQueue(); break;
				case 2: deQueue(); break;
				default: 	setcolor(RED);//RED
							settextstyle(1,0,5);outtextxy(630,630,"Invalid Choice");
							 delay(2000);
			}
			settextstyle(1,0,3);
			
			obj.clearPixel(600,550,1400,750);
			setcolor(15);//White
			outtextxy(1250,630,"		       		");//erasing the content of inside the circle
			rectangle(600,600,1400,700); //delay(5000);do left,top,right,bottom
			setcolor(15);
				
			outtextxy(630,630,"Would you like to proceed?	");
			fflush(stdin);
			another = getch();
		}while(another=='y' || another=='Y');
		
		getch();
} //End of queueInput function()


void GQueue :: enQueue()
{
	_Main obj;
	int data=0,num=0;
	bool valueSet=false,minusPresent=false;
	char d;
	obj.clearPixel(600,550,1400,750);
	if(front==(rear+1)%size){
		setcolor(4);//RED
		settextstyle(1,0,5);
		outtextxy(630,630,"OVER-FLOW");//yha ki coading baki hai
		delay(2000);
	}
	else{
			obj.clearPixel(600,550,1400,750);
			for(int countDigit=0;countDigit<3;	)
			{
				if(countDigit>=3) break;
				setcolor(15);//White
				settextstyle(1,0,2);
				rectangle(600,600,1400,700); //delay(5000);do left,top,right,bottom
				circle(1300,650,65);
				outtextxy(600,730,"WARNING: only Integer Input upto 3 digits are accpted");
				settextstyle(1,0,3);//font,direction,charsize
				outtextxy(630,630,"Enter the value to be inserted			");
				try{
						fflush(stdin);
						d = getch();
						setcolor(15);//White
						settextstyle(1,0,3);
						if(d>=48 && d<=57)	
						{
							data = (data*10) + ( d-'0');
					        countDigit++;
							char *coc = obj.int_to_charP(data);
							outtextxy(1255,630,coc);		
						}
						else if(d==13)//ASCII of Enter key --> indicate user entered the data 
							break;
						else if(d==45 && countDigit==0)//ASCII of Minus Sign
						{
							outtextxy(1245,630,"-");
							minusPresent = true;
						}
						else throw -1;
					}
				catch(int x)
				{			
					obj.clearPixel(630,625,1200,655);
					setcolor(RED);
					settextstyle(1,0,3);	//data=0; countDigit--;  outtextxy(1255,630,"		");
					outtextxy(630,630,"Invalid Input Exception");
					delay(2000);  return;
				}
				
			}//End of for loop
			if(data==0)	//User nai koi value nahi only enter press kiya toh zero insert ho jayega
				return;
			if(front==-1 && rear==-1)
			{
				rear = front = 0;
				outtextxy(250,630,"  0  ");
			}
			else
			{
				rear=(rear+1)%size;
			}
			queue[rear] = data ;
			
			fflush(stdin);
			char *item=obj.int_to_charP(data);
			switch(rear) // pictorial re
			{
				case 0: if (minusPresent==true) outtextxy(90,250,"- ");
							outtextxy(100,250,item);	//data Element
							outtextxy(250,480," 0 ");	//rear Position		
							break;
				case 1: if (minusPresent==true) outtextxy(240,250,"- ");
							outtextxy(250,250,item);	//data Element
							outtextxy(250,480,"  1  "); 
							break;
				case 2: if (minusPresent==true) outtextxy(390,250,"- ");
							outtextxy(400,250,item);
							outtextxy(250,480,"  2  "); 
							break;
				case 3: if (minusPresent==true) outtextxy(540,250,"- ");
							outtextxy(550,250,item);
							outtextxy(250,480,"  3  "); 
							break;
				case 4: if (minusPresent==true) outtextxy(690,250,"- ");
							outtextxy(700,250,item);
							outtextxy(250,480,"  4  "); 
							break;
				case 5: if (minusPresent==true) outtextxy(840,250,"- ");
							outtextxy(850,250,item);
							outtextxy(250,480,"  5  "); 
							break;
				case 6: if (minusPresent==true) outtextxy(990,250,"- ");
							outtextxy(1000,250,item);
							outtextxy(250,480,"  6  "); 
							break;
				case 7: if (minusPresent==true) outtextxy(1140,250,"- ");
					        outtextxy(1150,250,item);
							outtextxy(250,480,"  7  "); 
							break;
				case 8: if (minusPresent==true) outtextxy(1290,250,"- ");
							outtextxy(1300,250,item);
							outtextxy(250,480,"  8  "); 
							break;
				case 9: if (minusPresent==true) outtextxy(1440,250,"- ");
							outtextxy(1450,250,item);
							outtextxy(250,480,"  9  "); break;
			}
		}//end of outer else
}//End of enQueue function()

 
void GQueue :: deQueue()
{
	int num;
	if(front==-1 && rear==-1)
	{
		setcolor(4);//RED
		settextstyle(1,0,5);
		outtextxy(630,630,"UNDER FLOW 		    ");
		delay(2000); return;
	}
	else{
			num = queue[front];
			setcolor(0);
			settextstyle(1,0,3);
			switch(front) // pictorial re
			{	//erasing content
				case 0: outtextxy(90,250,"1234"); break;
				case 1: outtextxy(240,250,"	       "); break;
				case 2: outtextxy(390,250,"        "); break;
				case 3: outtextxy(540,250,"        "); break;
				case 4: outtextxy(690,250,"        "); break;
				case 5: outtextxy(840,250,"        "); break;
				case 6: outtextxy(990,250," 	      "); break;
				case 7: outtextxy(1140,250,"          "); break;
				case 8: outtextxy(1290,250,"          "); break;
				case 9: outtextxy(1440,250,"          "); break;
			}
			setcolor(WHITE);
			if(rear == front)
			{
				rear = front = -1;	
				outtextxy(250,480,"	-1	");//rear
				outtextxy(250,630,"	-1	");//front
			}
			else
			{
				front = (front+1)%size;	
				switch(front)
				{
					case 0: outtextxy(250,630,"  0  ");	break;
					case 1: outtextxy(250,630,"  1  "); break;
					case 2: outtextxy(250,630,"  2  "); break;
					case 3: outtextxy(250,630,"  3  "); break;
					case 4: outtextxy(250,630,"  4  "); break;
					case 5: outtextxy(250,630,"  5  "); break;
					case 6: outtextxy(250,630,"  6  "); break;
					case 7: outtextxy(250,630,"  7  "); break;
					case 8: outtextxy(250,630,"  8  "); break;
					case 9: outtextxy(250,630,"  9  "); break;
				}
				
			}
	}//End of outer else
}//End of deQueue function()

GQueue :: ~GQueue()
{
	front = rear = -1;
}

